---
phase: 01-process-monitoring-core
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/main.rs
  - src/app_controller.rs
autonomous: true

must_haves:
  truths:
    - "User can configure process collection interval via CLI flag --process-interval"
    - "ProcessMonitor starts collecting data when application starts"
    - "Default collection interval is 5 seconds if not specified"
  artifacts:
    - path: "src/main.rs"
      provides: "CLI argument for process collection interval"
      contains: "process_interval"
    - path: "src/app_controller.rs"
      provides: "ProcessMonitor integration in ApplicationController"
      contains: "process_monitor"
  key_links:
    - from: "src/main.rs"
      to: "ApplicationController"
      via: "Pass process_interval to new()"
      pattern: "ApplicationController::new.*process_interval"
    - from: "src/app_controller.rs"
      to: "ProcessMonitor"
      via: "Initialize and start collection"
      pattern: "ProcessMonitor::new|start_collection"
    - from: "src/main.rs"
      to: "run_web_server"
      via: "Pass process_monitor to web server"
      pattern: "run_web_server.*process_monitor"
---

<objective>
Integrate ProcessMonitor into application lifecycle with configurable collection interval via CLI.

Purpose: Wire process monitoring into existing ApplicationController, add CLI configuration, and ensure ProcessMonitor starts on app launch.
Output: Updated CLI args with --process-interval flag, ApplicationController managing ProcessMonitor lifecycle, web server receiving process_monitor reference.
</objective>

<execution_context>
@/home/agentsmith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/agentsmith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-process-monitoring-core/01-CONTEXT.md
@.planning/phases/01-process-monitoring-core/01-RESEARCH.md
@.planning/phases/01-process-monitoring-core/01-01-SUMMARY.md
@src/main.rs
@src/app_controller.rs
</context>

<tasks>

<task type="auto">
  <name>Add CLI flag for process collection interval</name>
  <files>src/main.rs</files>
  <action>
Update src/main.rs to add process collection configuration:

1. Add process_interval field to Args struct:
   - Add field after `follow`:
     ```rust
     /// Process collection interval in seconds
     #[arg(short = 'p', long, default_value = "5")]
     process_interval: u64,
     ```

2. Update ApplicationController::new() call to accept process_interval:
   - Change both calls (line ~56 and ~74) from:
     ```rust
     let mut app = ApplicationController::new(&args.data_dir)?;
     ```
     To:
     ```rust
     let mut app = ApplicationController::new(&args.data_dir, args.process_interval)?;
     ```

3. Update run_web_server calls (line ~65) to pass process_monitor:
   - Get process_monitor from app BEFORE moving app:
     ```rust
     let process_monitor = app.get_process_monitor();
     ```
   - Update run_web_server call:
     ```rust
     rt.block_on(run_web_server(&data_dir, shutdown_signal, process_monitor));
     ```

Follow existing patterns: CLI arg with default value, short flag, doc comment describing purpose.
  </action>
  <verify>
cargo build succeeds
grep -n "process_interval" src/main.rs shows new CLI arg and usage
  </verify>
  <done>
- Args struct has process_interval field with default value 5
- ApplicationController::new() receives process_interval parameter in both call sites
- run_web_server receives process_monitor parameter
- CLI help text documents --process-interval flag
  </done>
</task>

<task type="auto">
  <name>Integrate ProcessMonitor into ApplicationController</name>
  <files>src/app_controller.rs</files>
  <action>
Update src/app_controller.rs to manage ProcessMonitor lifecycle:

1. Add ProcessMonitor to ApplicationController struct:
   - Import: use crate::process_monitor::ProcessMonitor;
   - Import: use std::sync::Arc;
   - Add field after buffer: `process_monitor: Arc<ProcessMonitor>,`

2. Update new() signature and implementation:
   - Change signature: `pub fn new<P: AsRef<std::path::Path>>(data_dir: P, process_interval: u64) -> Result<Self>`
   - After buffer initialization, add:
     ```rust
     let process_monitor = Arc::new(ProcessMonitor::new());
     process_monitor.start_collection(process_interval);
     info!("Started process monitoring with {}s interval", process_interval);
     ```
   - Add to struct initialization: `process_monitor,`

3. Add getter method for web server:
   - Add method after get_shutdown_signal():
     ```rust
     pub fn get_process_monitor(&self) -> Arc<ProcessMonitor> {
         self.process_monitor.clone()
     }
     ```

4. Update test in mod tests section:
   - Update test_application_controller_creation to pass process_interval:
     ```rust
     let result = ApplicationController::new(temp_dir.path(), 5);
     ```
   - Update test_status_retrieval similarly

Follow existing patterns: Arc for shared ownership, info! logging for lifecycle events, getter methods for external access.
  </action>
  <verify>
cargo build succeeds
cargo test passes
grep -n "process_monitor" src/app_controller.rs shows field, initialization, getter
  </verify>
  <done>
- ApplicationController has process_monitor field of type Arc<ProcessMonitor>
- new() accepts process_interval parameter and initializes ProcessMonitor
- start_collection() called with interval during initialization
- get_process_monitor() getter method exists
- Tests updated to pass process_interval parameter
  </done>
</task>

</tasks>

<verification>
Full integration check:
```bash
cargo build --release
cargo test
cargo clippy --all-targets -- -D warnings
```

Runtime verification:
```bash
cargo run -- --help | grep "process-interval"
# Should show: -p, --process-interval <PROCESS_INTERVAL>  Process collection interval in seconds [default: 5]
```

Compilation confirms:
- main.rs calls ApplicationController::new with process_interval
- ApplicationController initializes ProcessMonitor
- Web server receives process_monitor reference
</verification>

<success_criteria>
- CLI accepts --process-interval flag with default of 5 seconds
- ApplicationController::new() signature updated with process_interval parameter
- ProcessMonitor initialized and started during app startup
- Web server receives process_monitor reference via updated run_web_server signature
- All tests pass
- No compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-process-monitoring-core/01-02-SUMMARY.md`
</output>
