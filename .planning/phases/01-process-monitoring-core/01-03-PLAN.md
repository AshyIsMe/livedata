---
phase: 01-process-monitoring-core
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - static/processes.html
  - static/processes.js
autonomous: true

must_haves:
  truths:
    - "User can view list of running processes in web interface"
    - "User can sort processes by clicking column headers"
    - "User can search/filter processes using fuzzy search"
    - "Process list auto-refreshes at configurable interval"
    - "User sees 'Updated X seconds ago' timestamp"
  artifacts:
    - path: "static/processes.html"
      provides: "Process monitoring web page"
      min_lines: 40
      contains: "processes-table"
    - path: "static/processes.js"
      provides: "Process table, search, auto-refresh logic"
      min_lines: 120
      contains: "Tabulator"
  key_links:
    - from: "static/processes.js"
      to: "/api/processes"
      via: "fetch() calls for data"
      pattern: "fetch.*api/processes"
    - from: "static/processes.js"
      to: "Tabulator"
      via: "table initialization and setData calls"
      pattern: "new Tabulator.*processes-table"
    - from: "static/processes.js"
      to: "search input"
      via: "debounced event listener"
      pattern: "addEventListener.*input.*debounce"
---

<objective>
Create web interface for viewing, searching, and monitoring system processes with auto-refresh.

Purpose: Provide user-facing interface for process monitoring - data table with sorting, fuzzy search, and configurable auto-refresh matching user's vision from CONTEXT.md.
Output: HTML page with process table, search input, refresh controls, and JavaScript implementing all interactive behaviors.
</objective>

<execution_context>
@/home/agentsmith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/agentsmith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-process-monitoring-core/01-CONTEXT.md
@.planning/phases/01-process-monitoring-core/01-RESEARCH.md
@.planning/phases/01-process-monitoring-core/01-01-SUMMARY.md
@.planning/phases/01-process-monitoring-core/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create process monitoring HTML page</name>
  <files>static/processes.html</files>
  <action>
Create static/processes.html with structure matching existing UI patterns:

1. HTML structure:
   - DOCTYPE html with charset UTF-8
   - Title: "livedata - Process Monitor"
   - Link to Tabulator CSS: https://unpkg.com/tabulator-tables@6.4.1/dist/css/tabulator_simple.min.css
   - Script tag for Tabulator: https://unpkg.com/tabulator-tables@6.4.1/dist/js/tabulator.min.js
   - Script tag for processes.js (defer)

2. Header section:
   - h1: "Process Monitor"
   - Link to logs page: <a href="/">Back to Logs</a>

3. Controls section (div with controls styling):
   - Search input: `<input type="text" id="search-input" placeholder="Search processes (fuzzy)..." />`
   - Auto-refresh controls:
     - Label: "Auto-refresh:"
     - Checkbox: `<input type="checkbox" id="auto-refresh" checked />`
     - Label: "Interval (seconds):"
     - Number input: `<input type="number" id="refresh-interval" value="5" min="1" max="60" />`
   - Last updated timestamp: `<span id="last-updated">Never</span>`
   - Manual refresh button: `<button id="refresh-button">Refresh Now</button>`

4. Table container:
   - `<div id="processes-table"></div>`

5. Styling (inline or <style> block):
   - Basic layout: max-width 1400px, margin auto, padding
   - Controls: flexbox layout with gap between elements
   - Search input: min-width 300px
   - Button styling: padding, cursor pointer
   - last-updated: muted color, smaller font

Follow minimal styling approach - functional over decorative. Use semantic HTML (labels, proper input types).
  </action>
  <verify>
ls static/processes.html exists
grep -c "processes-table" static/processes.html returns 1
grep -c "search-input" static/processes.html returns 1
  </verify>
  <done>
- static/processes.html exists with complete structure
- Page includes Tabulator CSS and JS from CDN
- Controls section has search input, auto-refresh checkbox, interval input, timestamp display
- Processes table container has id="processes-table"
- Page links to processes.js
  </done>
</task>

<task type="auto">
  <name>Implement process table with Tabulator</name>
  <files>static/processes.js</files>
  <action>
Create static/processes.js implementing process table, search, and auto-refresh:

1. Initialize Tabulator table on DOMContentLoaded:
   ```javascript
   let table;
   let allProcesses = [];
   
   document.addEventListener('DOMContentLoaded', () => {
     table = new Tabulator("#processes-table", {
       layout: "fitColumns",
       initialSort: [{ column: "cpu_percent", dir: "desc" }],
       columns: [
         { title: "PID", field: "pid", sorter: "number", width: 100 },
         { title: "Name", field: "name", sorter: "string" },
         { title: "CPU %", field: "cpu_percent", sorter: "number", 
           formatter: (cell) => cell.getValue().toFixed(1) + "%", width: 120 },
         { title: "Memory %", field: "memory_percent", sorter: "number",
           formatter: (cell) => cell.getValue().toFixed(1) + "%", width: 120 },
         { title: "User", field: "user_id", sorter: "string", width: 150 },
         { title: "Runtime", field: "runtime_display", sorter: "string", width: 150 }
       ]
     });
     
     initializeControls();
     fetchProcesses();
   });
   ```

2. Fetch processes from API:
   ```javascript
   async function fetchProcesses() {
     try {
       const response = await fetch('/api/processes');
       const data = await response.json();
       
       // Calculate memory % and format runtime
       allProcesses = data.processes.map(proc => {
         const totalMemoryKB = getTotalMemory(); // Estimate: 16GB default
         const memoryPercent = (proc.memory_bytes / 1024 / totalMemoryKB) * 100;
         const runtimeDisplay = formatRuntime(proc.runtime_secs);
         
         return { ...proc, memory_percent: memoryPercent, runtime_display: runtimeDisplay };
       });
       
       filterAndDisplay();
       updateTimestamp(data.timestamp);
     } catch (error) {
       console.error('Failed to fetch processes:', error);
     }
   }
   
   // Helper: Assume 16GB RAM if unavailable (no API for total memory yet)
   function getTotalMemory() {
     return 16 * 1024 * 1024; // 16GB in KB
   }
   
   // Helper: Format seconds to human readable (e.g., "2h 15m", "45m 30s")
   function formatRuntime(seconds) {
     if (seconds < 60) return seconds + "s";
     const minutes = Math.floor(seconds / 60);
     if (minutes < 60) return minutes + "m " + (seconds % 60) + "s";
     const hours = Math.floor(minutes / 60);
     const mins = minutes % 60;
     if (hours < 24) return hours + "h " + mins + "m";
     const days = Math.floor(hours / 24);
     return days + "d " + (hours % 24) + "h";
   }
   ```

3. Implement search with debouncing (300ms):
   ```javascript
   let debounceTimer;
   const DEBOUNCE_MS = 300;
   
   function initializeControls() {
     document.getElementById('search-input').addEventListener('input', (e) => {
       clearTimeout(debounceTimer);
       debounceTimer = setTimeout(() => {
         filterAndDisplay();
       }, DEBOUNCE_MS);
     });
     
     // Refresh button
     document.getElementById('refresh-button').addEventListener('click', fetchProcesses);
     
     // Auto-refresh checkbox and interval
     document.getElementById('auto-refresh').addEventListener('change', updateAutoRefresh);
     document.getElementById('refresh-interval').addEventListener('change', updateAutoRefresh);
     
     updateAutoRefresh();
   }
   
   function filterAndDisplay() {
     const query = document.getElementById('search-input').value.toLowerCase().trim();
     
     if (!query) {
       table.setData(allProcesses);
       return;
     }
     
     // Simple fuzzy-ish filter: matches if all query chars appear in order in searchable text
     const filtered = allProcesses.filter(proc => {
       const searchText = `${proc.pid} ${proc.name} ${proc.user_id || ''} ${proc.cpu_percent.toFixed(1)}`.toLowerCase();
       return fuzzyMatch(query, searchText);
     });
     
     table.setData(filtered);
   }
   
   // Simple fuzzy matching: all query chars must appear in order
   function fuzzyMatch(query, text) {
     let textIndex = 0;
     for (let char of query) {
       textIndex = text.indexOf(char, textIndex);
       if (textIndex === -1) return false;
       textIndex++;
     }
     return true;
   }
   ```

4. Implement auto-refresh:
   ```javascript
   let autoRefreshInterval;
   
   function updateAutoRefresh() {
     if (autoRefreshInterval) {
       clearInterval(autoRefreshInterval);
       autoRefreshInterval = null;
     }
     
     const enabled = document.getElementById('auto-refresh').checked;
     const intervalSecs = parseInt(document.getElementById('refresh-interval').value);
     
     if (enabled && intervalSecs > 0) {
       autoRefreshInterval = setInterval(fetchProcesses, intervalSecs * 1000);
     }
   }
   
   function updateTimestamp(isoTimestamp) {
     const date = new Date(isoTimestamp);
     const secondsAgo = Math.floor((Date.now() - date.getTime()) / 1000);
     document.getElementById('last-updated').textContent = 
       `Updated ${secondsAgo}s ago (${date.toLocaleTimeString()})`;
   }
   ```

Use plain JavaScript (no frameworks). Comments explaining key sections. Error handling with console.error and user-visible feedback if API fails.
  </action>
  <verify>
ls static/processes.js exists
grep -c "Tabulator" static/processes.js returns at least 1
grep -c "fetchProcesses" static/processes.js returns at least 3
grep -c "fuzzyMatch" static/processes.js returns at least 2
  </verify>
  <done>
- static/processes.js exists with complete implementation
- Tabulator table initialized with 6 columns (PID, name, CPU%, memory%, user, runtime)
- Table sorted by CPU% descending by default
- Search input filters table with debounced fuzzy matching
- Auto-refresh enabled by default at 5-second intervals
- Timestamp shows "Updated X seconds ago"
- Memory % calculated from memory_bytes (assumes 16GB total for now)
- Runtime formatted as human-readable (days/hours/minutes/seconds)
  </done>
</task>

<task type="auto">
  <name>Add navigation link to process monitor</name>
  <files>static/index.html</files>
  <action>
Check if static/index.html exists (for logs page). If it exists, add navigation link to processes page:

1. Locate the header or navigation section (likely near top of body)

2. Add link to processes page:
   - If there's a nav or links section, add: `<a href="/processes.html">Processes</a>`
   - Match existing link styling

3. If static/index.html does NOT exist, create minimal version:
   ```html
   <!DOCTYPE html>
   <html>
   <head>
     <meta charset="UTF-8">
     <title>livedata</title>
   </head>
   <body>
     <h1>livedata</h1>
     <nav>
       <a href="/processes.html">Process Monitor</a>
     </nav>
   </body>
   </html>
   ```

Keep changes minimal - just cross-linking between pages for navigation.
  </action>
  <verify>
grep -l "processes.html" static/index.html || echo "Link added or index.html created"
  </verify>
  <done>
- static/index.html exists (created if missing)
- Link to processes.html added for navigation
- Users can navigate between logs and processes pages
  </done>
</task>

</tasks>

<verification>
File structure check:
```bash
ls -l static/processes.html static/processes.js
```

Content validation:
```bash
# Check HTML has required elements
grep "processes-table" static/processes.html
grep "search-input" static/processes.html
grep "auto-refresh" static/processes.html

# Check JS has required functions
grep "fetchProcesses" static/processes.js
grep "fuzzyMatch" static/processes.js
grep "Tabulator" static/processes.js
```

Integration readiness:
- HTML references processes.js correctly
- JS fetches from /api/processes endpoint
- Table columns match ProcessInfo struct fields
</verification>

<success_criteria>
- static/processes.html exists with complete UI structure
- static/processes.js implements Tabulator table with 6 columns
- Search functionality uses fuzzy matching with 300ms debounce
- Auto-refresh defaults to enabled at 5-second intervals
- Timestamp displays "Updated X seconds ago" after each refresh
- Default sort is by CPU% descending
- Memory % calculated from bytes (temporary 16GB assumption)
- Runtime formatted as human-readable duration
- Navigation link added to index page
</success_criteria>

<output>
After completion, create `.planning/phases/01-process-monitoring-core/01-03-SUMMARY.md`
</output>
